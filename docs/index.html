<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>音楽除去 サンプル音源まとめ</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; margin: 20px; line-height: 1.6; }
    h1 { font-size: 1.4rem; margin-bottom: 0.25rem; }
    .small { color: #666; font-size: 0.9rem; }
    .row { display: flex; gap: 16px; align-items: stretch; flex-wrap: wrap; margin-top: 10px; }
    .panel { border: 1px solid #eee; border-radius: 10px; padding: 12px; background: #fff; }
    .panel .label { font-weight: 700; margin-bottom: 6px; }
    .left { min-width: 320px; flex: 1 1 320px; }
    .right { flex: 2 1 520px; }
    select { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ddd; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 18px; margin-top: 14px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; }
    .card .label { font-weight: 600; margin-bottom: 6px; }
    audio { width: 100%; margin-top: 8px; }
    .error { color: #b00020; }
    .langOverlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.95); z-index: 1000;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 20px;
    }
    .langOverlay.hidden { display: none; }
    .langBtn {
      padding: 16px 32px; font-size: 1.2rem; border: 2px solid #2d6cdf;
      border-radius: 8px; background: #fff; cursor: pointer;
      transition: background 0.2s;
    }
    .langBtn:hover { background: #eef4ff; }
    .mainContent { display: none; }
    .mainContent.visible { display: block; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <div id="langOverlay" class="langOverlay">
    <div style="font-size: 1.3rem; margin-bottom: 10px;">言語を選択 / Select Language</div>
    <button class="langBtn" data-lang="ja">日本語</button>
    <button class="langBtn" data-lang="en">English</button>
  </div>

  <div id="mainContent" class="mainContent">
    <h1 id="pageTitle">音楽除去 サンプル音源まとめ</h1>
    <div id="pageIntro" class="small">音楽除去実験で出力した音源が視聴できます。</div>
    <div class="small" style="margin-top:6px;">
      <label for="langSelect">Language:</label>
      <select id="langSelect" aria-label="Language">
        <option value="ja">日本語</option>
        <option value="en">English</option>
      </select>
    </div>

    <div class="row">
      <div class="panel left">
        <div id="pickDateLabel" class="small" style="margin-bottom:6px;">変更内容を選択</div>
        <select id="dateSelect" aria-label="Choose change"></select>
        <div id="error" class="error small" style="margin-top:12px;"></div>
      </div>

      <div class="panel right">
        <div id="cards" class="grid" aria-live="polite"></div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll("\"", "&quot;")
        .replaceAll("'", "&#039;");
    }

    const I18N = {
      ja: {
        pageTitle: "音楽除去 サンプル音源まとめ",
        pageIntro: "音楽除去実験で出力した音源が視聴できます。",
        pickDate: "変更内容を選択",
        labelsByKind: {
          mixture: "混合音源",
          target: "元の環境音",
          output: "出力音源",
          output_old: "出力音源（従来手法）",
          output_new: "出力音源（提案手法）",
          output_no_metricgan: "出力音源（MetricGAN+なし）",
          output_with_metricgan: "出力音源（MetricGAN+あり）",
          output_baseline: "出力音源（Baseline）",
          output_improved: "出力音源（改善版）"
        }
      },
      en: {
        pageTitle: "Music Removal Sample Audio Collection",
        pageIntro: "You can listen to audio outputs from music removal experiments.",
        pickDate: "Select change",
        labelsByKind: {
          mixture: "Mixture",
          target: "Target",
          output: "Output",
          output_old: "Output (traditional)",
          output_new: "Output (proposed)",
          output_no_metricgan: "Output (no MetricGAN+)",
          output_with_metricgan: "Output (with MetricGAN+)",
          output_baseline: "Output (baseline)",
          output_improved: "Output (improved)"
        }
      }
    };

    let currentLang = localStorage.getItem("lang") || "ja";
    let manifestData = null;

    // Language selection overlay
    const langOverlay = $("langOverlay");
    const mainContent = $("mainContent");
    
    if (!localStorage.getItem("lang")) {
      langOverlay.classList.remove("hidden");
      mainContent.classList.remove("visible");
    } else {
      langOverlay.classList.add("hidden");
      mainContent.classList.add("visible");
    }

    document.querySelectorAll(".langBtn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const lang = btn.getAttribute("data-lang");
        currentLang = lang;
        localStorage.setItem("lang", lang);
        langOverlay.classList.add("hidden");
        mainContent.classList.add("visible");
        initPage();
      });
    });

    function dateKey(set) {
      const d = (set && set.date) ? String(set.date) : "";
      const m = d.match(/\d{4}-\d{2}-\d{2}/);
      return m ? m[0] : "unknown";
    }

    function getAudioGroupKey(path) {
      // Group audio by directory (e.g., "components/", "demo_", etc.)
      // Extract directory or base prefix from path
      const parts = path.split("/");
      if (parts.length >= 2) {
        // Use directory name as group key (e.g., "components", "demo_schedule")
        const dirName = parts[parts.length - 2];
        return dirName;
      }
      // Fallback: use filename prefix (e.g., "demo_mixture" -> "demo")
      const fileName = parts[parts.length - 1] || "";
      const match = fileName.match(/^([^_]+)_/);
      return match ? match[1] : "default";
    }

    function renderAudio(selectedSet) {
      const cards = [];
      
      if (!selectedSet || !Array.isArray(selectedSet.items)) {
        $("cards").innerHTML = "";
        return;
      }

      // Group items by audio group (same directory or prefix)
      const groups = new Map();
      
      for (const it of selectedSet.items) {
        const kind = (it && it.kind) ? String(it.kind) : "";
        if (kind === "mixture" || kind === "target" || kind === "output" || kind.startsWith("output_")) {
          const groupKey = getAudioGroupKey(it.path || "");
          if (!groups.has(groupKey)) {
            groups.set(groupKey, { mixture: null, target: null, outputs: [] });
          }
          const group = groups.get(groupKey);
          
          if (kind === "mixture") {
            group.mixture = it;
          } else if (kind === "target") {
            group.target = it;
          } else if (kind === "output" || kind.startsWith("output_")) {
            // Classify outputs for clearer UI.
            // Priority: old/new (traditional/proposed) > MetricGAN+ classification > generic.
            const labelStr = (it.label || "").toLowerCase();
            const pathStr = (it.path || "").toLowerCase();
            const fileText = (labelStr + " " + pathStr).toLowerCase();

            let tag = "other"; // old | new | no_metricgan | with_metricgan | other

            const isOld = (kind === "output_old") || fileText.includes("従来") || fileText.includes("_old") || fileText.includes("old.wav");
            const isNew = (kind === "output_new") || fileText.includes("提案") || fileText.includes("_new") || fileText.includes("new.wav");

            if (isOld && !isNew) {
              tag = "old";
            } else if (isNew && !isOld) {
              tag = "new";
            } else if (kind === "output_with_metricgan" || kind === "output_improved") {
              tag = "with_metricgan";
            } else if (kind === "output_no_metricgan" || kind === "output_baseline") {
              tag = "no_metricgan";
            } else {
              // Keyword-based fallback for MetricGAN+ (don't use set ID; it's too broad)
              const positiveIndicators = [
                "改善あり", "metricgan", "improved", "with_metricgan",
                "distill", "mg_only"
              ];
              const negativeIndicators = [
                "改善なし", "no_metricgan", "baseline", "without_metricgan"
              ];
              const hasNegative = negativeIndicators.some(ind => fileText.includes(ind));
              const hasPositive = positiveIndicators.some(ind => fileText.includes(ind));
              tag = (hasPositive && !hasNegative) ? "with_metricgan" : "no_metricgan";
            }

            const itemLabel = it.label || I18N[currentLang].labelsByKind[kind] || I18N[currentLang].labelsByKind.output;
            group.outputs.push({ label: itemLabel, path: it.path, tag: tag });
          }
        }
      }

      // Render each group: mixture, target, then outputs (separated by MetricGAN+ status)
      for (const [groupKey, group] of groups) {
        // Show mixture and target for this group
        if (group.mixture) {
          const label = escapeHtml(I18N[currentLang].labelsByKind.mixture);
          cards.push(`
            <div class="card">
              <div class="label">${label}</div>
              <audio controls preload="none" src="${escapeHtml(group.mixture.path)}"></audio>
            </div>
          `);
        }
        
        if (group.target) {
          const label = escapeHtml(I18N[currentLang].labelsByKind.target);
          cards.push(`
            <div class="card">
              <div class="label">${label}</div>
              <audio controls preload="none" src="${escapeHtml(group.target.path)}"></audio>
            </div>
          `);
        }

        const outputsOld = group.outputs.filter(o => o.tag === "old");
        const outputsNew = group.outputs.filter(o => o.tag === "new");
        const outputsNoMetricGAN = group.outputs.filter(o => o.tag === "no_metricgan");
        const outputsWithMetricGAN = group.outputs.filter(o => o.tag === "with_metricgan");
        const outputsOther = group.outputs.filter(o => o.tag === "other");

        function renderOutputSection(sectionLabel, items) {
          if (!items || items.length === 0) return;
          cards.push(`<div class="card" style="grid-column: 1 / -1;"><div class="label" style="font-size: 1.1rem; margin-bottom: 12px;">${escapeHtml(sectionLabel)}</div></div>`);
          for (const it of items) {
            cards.push(`
              <div class="card">
                <div class="label">${escapeHtml(it.label)}</div>
                <audio controls preload="none" src="${escapeHtml(it.path)}"></audio>
              </div>
            `);
          }
        }

        // Prefer old/new sections when present (results_20260124 style).
        if (outputsOld.length > 0 || outputsNew.length > 0) {
          const oldLabel = I18N[currentLang].labelsByKind.output_old || (currentLang === "ja" ? "出力音源（従来手法）" : "Output (traditional)");
          const newLabel = I18N[currentLang].labelsByKind.output_new || (currentLang === "ja" ? "出力音源（提案手法）" : "Output (proposed)");
          renderOutputSection(oldLabel, outputsOld);
          renderOutputSection(newLabel, outputsNew);
          renderOutputSection(I18N[currentLang].labelsByKind.output, outputsOther);
        } else if (outputsNoMetricGAN.length > 0 || outputsWithMetricGAN.length > 0) {
          // Otherwise, use MetricGAN+ grouping when available.
          renderOutputSection(I18N[currentLang].labelsByKind.output_no_metricgan, outputsNoMetricGAN);
          renderOutputSection(I18N[currentLang].labelsByKind.output_with_metricgan, outputsWithMetricGAN);
        } else {
          // Fallback: just list outputs.
          renderOutputSection(I18N[currentLang].labelsByKind.output, outputsOther);
        }
      }

      $("cards").innerHTML = cards.join("");
    }

    function applyLang() {
      const t = I18N[currentLang];
      $("pageTitle").textContent = t.pageTitle;
      $("pageIntro").textContent = t.pageIntro;
      $("pickDateLabel").textContent = t.pickDate;
      $("langSelect").value = currentLang;
    }

    async function initPage() {
      try {
        const resp = await fetch("manifest.json?ts=" + Date.now(), { cache: "no-store" });
        if (!resp.ok) throw new Error(`manifest load failed: ${resp.status}`);
        manifestData = await resp.json();

        const sets = Array.isArray(manifestData.sets) ? manifestData.sets : [];
        if (sets.length === 0) throw new Error("No sets found in manifest");

        const byId = new Map(sets.map((s) => [s.id, s]));
        const latestSetId = (manifestData.latest_set_id && byId.has(manifestData.latest_set_id)) ? manifestData.latest_set_id : null;
        const dateMeta = (manifestData.date_meta && typeof manifestData.date_meta === "object") ? manifestData.date_meta : {};

        // Group sets by date
        const byDate = new Map();
        for (const s of sets) {
          const k = dateKey(s);
          if (!byDate.has(k)) byDate.set(k, []);
          byDate.get(k).push(s);
        }
        
        // Sort dates: oldest -> newest
        const dates = Array.from(byDate.keys()).sort((a, b) => {
          if (a === "unknown") return 1;
          if (b === "unknown") return -1;
          return a < b ? -1 : (a > b ? 1 : 0);
        });

        // Build date select options: summary + date
        const dateSel = $("dateSelect");
        const latestDate = latestSetId ? dateKey(byId.get(latestSetId)) : null;
        
        dateSel.innerHTML = dates.map((d) => {
          const m = dateMeta[d] || {};
          const summary = currentLang === "en"
            ? (m.summary_en || m.summary || "")
            : (m.summary_ja || m.summary || "");
          const label = summary ? `${summary} (${d})` : d;
          const suffix = (latestDate && d === latestDate) ? " (最新)" : "";
          return `<option value="${escapeHtml(d)}">${escapeHtml(label + suffix)}</option>`;
        }).join("");

        // Prefer latestDate if available, otherwise use the newest date (last in sorted array)
        const initialDate = (latestDate && byDate.has(latestDate)) ? latestDate : (dates.length > 0 ? dates[dates.length - 1] : dates[0]);
        let currentDate = initialDate;

        function selectDate(dateKeyStr) {
          currentDate = dateKeyStr;
          const list = byDate.get(dateKeyStr) || [];
          // Prefer latest set if it's in this date, else first set
          const prefer = (latestSetId && list.some((s) => s.id === latestSetId)) ? latestSetId : (list[0] ? list[0].id : null);
          const selectedSet = prefer && byId.has(prefer) ? byId.get(prefer) : null;
          renderAudio(selectedSet);
        }

        dateSel.value = initialDate;
        selectDate(initialDate);

        dateSel.addEventListener("change", () => {
          selectDate(dateSel.value);
        });

        // Language selector
        const langSel = $("langSelect");
        langSel.value = currentLang;
        langSel.addEventListener("change", () => {
          currentLang = langSel.value === "en" ? "en" : "ja";
          localStorage.setItem("lang", currentLang);
          applyLang();
          // Re-render date options
          dateSel.innerHTML = dates.map((d) => {
            const m = dateMeta[d] || {};
            const summary = currentLang === "en"
              ? (m.summary_en || m.summary || "")
              : (m.summary_ja || m.summary || "");
            const label = summary ? `${summary} (${d})` : d;
            const suffix = (latestDate && d === latestDate) ? (currentLang === "en" ? " (latest)" : " (最新)") : "";
            return `<option value="${escapeHtml(d)}">${escapeHtml(label + suffix)}</option>`;
          }).join("");
          dateSel.value = currentDate;
          selectDate(currentDate);
        });

        applyLang();
      } catch (e) {
        $("error").textContent = `Error: ${e && e.message ? e.message : e}`;
      }
    }

    if (localStorage.getItem("lang")) {
      initPage();
    }
  </script>
</body>
</html>
